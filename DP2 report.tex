\documentclass[letterpaper]{article}

\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{clrscode4e}


\begin{document}

\section{Introduction}

When deployed to a disaster-stricken area, first responders need to be able to efficiently communicate their
location and other information to their base camp. However, communication infrastructure is often unreliable
or inaccessible during these crises. To solve this problem, we designed AdHocPro, an ad-hoc wireless network of
portable devices that allows responders to send messages to their base camp in a reliable, efficient, and safe
way. Our rigorous design accounts for the rapid changes in network topology that occur as the responders move 
around, as well as the possible presence of malicious agents in the field. 

\subsection{Design Overview}

Our design is built on top of 802.11 MAC and uses TCP in order return ACKs when a node successfully receives
a packet from another node.
\\

\noindent Because wireless links suffer from interference if multiple nodes attempt to transmit at the same time,
802.11 MAC allows our nodes to sense the medium and transmit only if the medium is idle. ...MORE 802.11
IS GOOD STUFF HERE...(TODO)
\\

\noindent Our link-state based routing protocol enables each first responder to send messages to the base anytime
there is a sequence of connected nodes between the sender and the base station. The link-state advertisements 
sent by our routing protocol from each node at every advertisement interval of 30 seconds will contain the node's
GPS  information, reliably delivering the location information of each node to the base station no more than
5 minutes after the base previously learned the location of that node.
\\

\noindent A cost metric, calculated by the integration step of our routing protocol, enables our design to measure
the effectiveness of each possible path to the base station and choose paths which maximize the image 
throughput of the network. The design also draws upon elements of data center TCP (DCTCP) in order to relay 
information regarding queues at each node to minimize the effects of network congestion when there are many
image messages to be delivered to the base station. 
\\

\noindent The final component of our design is an authentication system. Our design seeks to accept messages
only from first responders, and should not forward messages from non-trusted nodes of include such nodes in
its routes. To this end, the system uses a public/private key signature scheme, where each node has a private
key which it uses to sign its messages. Other nodes may then decode the message using the sender's
public key, but even if a non-trusted node hears and decodes a message using the public key, it will be 
unable to sign any messages without the private key of a known node. A sequence number attached to each
message allows nodes to discard messages which they have previously heard, stymying replay attacks from
malicious sources.

\subsection{Tradeoffs and Design Decisions}

The central design consideration of AdHocPro is efficiency. System components are designed to provide
functionality which contributes to multiple system requirements while maintaining relative simplicity.
This is emphasized in design decisions because of the number of the large number of different use cases,
network topologies, and edge case scenarios which ad-hoc wireless networks experience. If these scenarios
can all be accounted without introducing additional components, our system will be more robust. A 
secondary design emphasis was placed on correctness. If given the choice between a less computationally
expensive but possibly incorrect metric and a computation-heavy but likely correct metric, AdHocPro will
use the latter. This is because every packet sent adds to network congestion, and mistakes are therefore
very costly.
\\

\noindent As a result of these decisions, link-state was chosen over distance vector as AdHocPro's routing
protocol. Link-state does come with a higher initial setup cost than distance vector as a greater number of
advertisements must flood the entire network. The overall bandwidth and time consumed by this operation
is relatively high. However, link-state gives each node a complete view of the network. If a link a packet's
original path fails, any node along the path may recompute a new path for a packet to take to the base. In
distance vector, a node only knows of the best path to take to a destination. Therefore if a link fails, the
packet will stall until the next advertisement window.
\\

\noindent COST METRIC TRADEOFFS (TODO)
\\

\noindent The authentification system was designed with an emphasis on meeting requirements and simplicity.
Each node signs its own messages with its private key, and the resulting ciphertext can be decrypted by any
node that has the public key. Therefore, only trusted nodes will be able to compose and forward messages, but
nodes may still use the \textsc{broadcast} function as all of its neighbors, including non-trusted nodes, are
capable of deciphering its messages. Disallowing non-trusted nodes from viewing messages is not a system 
requirement, and would also complicate our security protocol, so we decided not to support this.

\section{Design}

\subsection{Routing protocol}

An effective and efficient routing protocol is necessary for nodes to determine the best paths to send
packets to the base without constantly congesting the network.
\\

\noindent Our routing protocol is based on a link-state advertisement scheme in which neighboring nodes 
inform each other of incremental changes. Upon receiving an advertisement, a node will use the 
\textsc{broadcast} function to forward it to all its neighbors. As a result of this flooding process,
each node's routing table will contain a complete map of the network. Then, each node will independently
run a computation based on our cost metric to find the shortest routes to the base. As long as the nodes
have a consistent view of the topology and the same metric, resulting routes at different nodes will
correspond to a valid path.
\\

\noindent Every time a node successfully sends a packet to a recipient, the recipient sends back an ACK.
If a node does not receive an ACK within 10 milliseconds of sending a packet, the packet is considered
lost. This figure is approximately twice the RTT between a laptop on MIT wireless and www.mit.edu.

\subsubsection{Location information}

\noindent Because the link-state routing protocol floods network updates across all nodes in the network,
an advertisement from every single node will reach the base station. Thus, location updates can be built 
into the system's routing protocol itself. Location information for each node is added to its 
advertisements, so once the link-state protocol converges, the base station is guaranteed to know the
location of every node reachable from the base.

\subsubsection{Data structures}

\noindent There are two data structures which our routing protocol uses: \emph{link-state advertisements} 
(LSAs) and \emph{network tables}. 
\\

\noindent Link-state advertisements have the following format:

$$ [\textnormal{nodeID}, \textnormal{GPS}, \textnormal{seq}, (nbhr1, lossprob1), 
(nbhr2, lossprob2), (nbhr3, lossprob3), ...] $$

\noindent Where \emph{nodeID} is the ID of the node, each \emph{nhbr} is a current neighbor of the node,
\emph{lossprob} is that neighbor's corresponding loss probability, and \emph{GPS} is the current location
reading. Additionally, each LSA has a sequence number, \emph{seq} that starts at 0 when the node turns on
and increments by 1 every time the node issues an LSA. When a node receives an LSA that originated at another
node, $n$, it first checks the sequence number of the last LSA from $n$. If the current sequence number is 
greater than the saved value for $n$, then the node re-broadcasts the LSA to its neighbors, and updates the 
saved value. Otherwise, it discards the LSA, because that same or later LSA must have been re-broadcasted 
before by the node. 
\\

\noindent Network tables: The network table must store LSAs issued from every node in the network. This
table will enable a node to reconstruct the entire network and run a cost-finding algorithm in order to
determine the best path a packet should take to reach the base. (TODO: FIGURES)
\\

\subsubsection{Updating the network topology}

\noindent Initially, the network undergoes the following procedure that discovers the network topology:

\begin{enumerate}
  \item Each node constructs its link-state advertisement by calling \textsc{scan}. 
  \item Nodes begin to flood the network with their LSAs, and build up their routing tables based on
  the advertisements they receive.
  \item Once all the LSAs have been discarded according to the routing table protocol, each node will have
  a complete map of the network. This will take time proportional to the diameter of the network, because
  LSAs must be propagated throughout the entire network.
\end{enumerate}

\noindent Every 30 seconds (based on each node's internal clock), all nodes in the network will call 
\textsc{scan} in order to determine whether or not the network topology and success probabilities of
paths have changed. If there are changes, nodes that are affected will construct LSAs accordingly and send
these advertisements into the network. Nodes that have not had major changes in status will not need to
create new advertisements. Resultingly, in a scenario in which not all nodes have changed their position
significantly over the course of 30 seconds, the network utilization of an update is smaller than the
network utilization of the initial network setup. Less network congestion implies that this update
procedure takes less time to complete than the setup.
\\

\noindent There exist, however, some cases in which the state of the network changes dramatically in 
between network update intervals, and it is desirable to send LSAs as soon as we recognize a change.
These situations are as follows:

\begin{enumerate}
  \item A path between two nodes fails, even though both are still connected to the network via other
  paths
  \item A path is added to the network without any new nodes joining the network
  \item A node becomes disconnected from the network
  \item A node is re-connected or added to the network
  \item The loss probability of a path changes dramatically, significantly affecting the cost of
  routes which go through the path
\end{enumerate}

\noindent In order to determine if one of these situations has occurred, a node will issue a 
\textsc{scan} whenever it encounters one of a few anomalous scenarios:

\begin{enumerate}
  \item A node attempts to send a packet down a link, but experiences (TO BE DETERMINED NUMBER) 
  consecutive timeouts without a successful send.
  \item A node successfully sends packets down a link (TO BE DETERMINED NUMBER) times without
  experiencing a single timeout
  \item A node hears a scan from a node that is not a neighbor in its view of the network topology
\end{enumerate}

\noindent If one or more neighbor nodes from the last time the node scanned no longer appear in 
the \textsc{scan} results, either paths between nodes have been lost or at least one node has
been disconnected from the network. If the \textsc{scan} returns no results, then the node knows
that it has been disconnected from the network. If the node was not disconnected from the network
but former neighbors are missing, the node will send an LSA which will propagate throughout the
entire network. Similarly, if the scan returns the same neighbor nodes as before but one or more
success probabilities have changed significantly, or if there are new neighbor nodes, the node will
send an LSA.
\\

\noindent This protocol will allow the network to update under any of the five situations in which
the state of the network changes in between network update intervals. One final addition to the
protocol pertains to disconnected nodes. When a node is disconnected from the network but wishes to
join it, it will issue a \textsc{scan} every 5 seconds. This will fully connect these nodes to the
network as soon as a connected node hears a scan. 

\subsection{Throughput for Sending Images}

When the situation calls for the aid of first responders, it is important that images taken by these have the highest throughput possible when sending to the base. The algorithm described in this section is the algorithm for routing images. Since advertisements (containing the GPS information of nodes) and new public-key packets have higher priority than images, this algorithm will only start sending image packets, when the other priority queue is empty and the images queue is not empty. Note that one packet cannot hold a full image, so images will be tried to be decided in different packets such that as much information can be fit into one packet while still leaving some small portion for appending information to that packet.

\subsection{Throughput Metric and the Routing Table}

After the routing protocol has finished its update period, it will start the integration phase yield an updated graph for the current state of the network topology. The cost in each edge will be $1/p_{i}$, where $p_{i}$ is the probability of success of sending to an adjacent node. The cost of an edge corresponds to the expected number of packets that a node has to send to yield one successful transmission. Once it has the graph it will construct a routing table containing the following information:

\begin{enumerate}
  \item The best cost path by taking the link going to adjacent node j. These costs will be considered during times of congestion.
  \item The Explicit Congestion Notification Bit (ECNB), which takes value 1 if going to node j takes us to a path that is considered congested or 0 otherwise.
\end{enumerate}

If the cost of an edge is $p_{i}$, then the cost of a path is defined by the following equation:

$$  Total \ Expected \ Transmition \ Cost = \sum_{i=0}^{k}\frac{1}{p_{i}}$$

It's important to realize that we are seeking to minimize this metric. Also note that the sum yields to sum the cost paths from the base to the current node.
\\

To fill out the table we do the following:

\begin{enumerate}
  \item Do Dijkstra's single shortest path from the current node.  
  \item Insert to the table the shortest path to the base on the entry where the node's own number is located.
  \item Then run Dijkra's on every neighbor node to the current node. Notate the current values obtained be $d_{i}$.
  \item Then, insert for node i the value $d_{i}$ plus the cost of taking the link connecting the current node to the adjacent node. (Note that if current node number = i, then it just insert the minimum cost path from itself).
\end{enumerate}

Consider the following table as an example:

\begin{table}[ht]
\caption{Routing Table} % title of Table
\centering % used for centering table
\begin{tabular}{c c c} % centered columns (3 columns)
\hline
\hline %inserts double horizontal lines
Node Number & Total Expectet Transmittion Cost [TETC] & Explicit Congention Notification Bit [ECNB]  \\[0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
0 [base] & 19 & 0\\
1 & 29 & 1\\
% inserting body of the table
2 & 31 & 0 \\
3 & 17 & 1\\ [1ex]
% [1ex] adds vertical space
\hline
%inserts single line
\end{tabular}
\label{table:nonlin}
% is used to refer this table in the text
\end{table}

\subsection{Throughput algorithm}

When sending images to the base, our goal is to try to send at maximum throughput with the current knowledge of the network. Therefore, in times of congestion the goal of our algorithm is to try to route around congestion, while still trying to attaining the maximum throughput with the current state of the network. Note that it will use the Explicit Congestion Notification Bit [ECNB] sent by adjacent nodes, to be aware of its own congestion.\\ 

The main idea of the algorithm is very simple, if it can send the current packet through the best path, send it through that path, else try to re-route by excluding the congested node in the path.\\

Recall that we only send images when the priority Queue for advertisments and public-keys is empty. Recall at the initialization phase, the contention window is of size 100 packets. Then the routing algorithm is implemented as follows by each node:

\begin{enumerate}

  \item First try sending a contention window of image packets to the best path if it's ECNB bit is 0 and the current packet is not marked its being re-routed. If a time-out ocurrs, and the congestion state of the neighbors does not change, repeat this step. If the congestion state changes to 1 of any neighbor, go to step 3 and change the appropriate ECN bit to 1.
  \item If the current node gets any packet notification from our neighbors saying that they are are congested, then we update the ECNB to 1.
  \item If our current best path is congested, then add information to the image packet specifying which (additional) node to avoid and now try re-routing by considering the next best link. When considering a best next link, only consider a next node where neither of its adjacent nodes has an ECNB of 1. 
  \item If the current image packet is marked as requiered re-routing, then compute another table of neighbors, but this time, exclude the congested nodes whenever Dijkstra's shortest path is computed.
  \item If at this point, we cannot re-route to any node because all of the adjacent nodes are next to too many nodes with an ECN of 1, then route using to the best path with a contention window to half the size and go back to step 1. Note: the contention window for an image cannot decrease to less than 10 packets.
  \item If we receive all acks and the ECN bit of the node we are sending packets did not change to 1, then increase the contention window and return to step 1.
\end{enumerate}

\subsection{Explicit Congestion Notification Bit}

An important but challening aspect of dealing with congestion is deciding when to consider a node is congested or not. Consider the figure 1: 
 
\begin{figure}[ht!]
\centering
\includegraphics[width=3in, height=2.2in]{Queue4.jpg}
\caption{\textbf{f1.txt} is the current version of the file}
\end{figure}

When a node has a queue length greather than k, then it will advertise that it is congested by sending a ECNB packet to all its neighbors. k is initialized for every node as 100. The way that k is changed depends on the number of neighbors around the current node and whether a packet was dropped or not. If a packet is dropped, it must not be informing quickly enough to its surrounding nodes about this, therefore decrease to half between wherever k is and 50:

$$ k = max\{50, \frac{k + 50}{2} \}$$

Every two scans we will adjust the value k. The first link to the path were you are rounting packets roughly determines the emptying rate. Therefore, depending on the percentage change of the value of this link, we will determine how much you change your queue:

if the percentage change is positive then it means we expect to send less packets, so the rate of packets leaving the queue is expected to decrease, so decrease the value of k:

$$ k = max\{50, k -  \frac{|\frac{1}{p_{new}} - \frac{1}{p_{old}}|}{\frac{1}{p_{old}}}|k - 50|   \}$$ 

if the percentage change is negative then we expect to see the rate of emptying the queue increase, therefore k is increased:

$$ k = min\{120, k +  \frac{|\frac{1}{p_{new}} - \frac{1}{p_{old}}|}{\frac{1}{p_{old}}}|k - 120|   \}$$ 

\subsection{Authentication}
When designing a communication system for first responders, its important that first responders are able to trust the messages they are receiving from fellow first responders. Therefore it is important to establish a mechanism by which first responders can authenticate “benign” messages (i.e. messages not sent by a malicious adversary). In the protocol presented in this paper, the base will use the RSA public-key cryptosystem to generate private and public-keys that it will then distribute to the first responders. In addition, everyone will have a table with an entry for each fellow first responder containing two important numbers:

\begin{enumerate}
  \item The first responder's public-key. 
  \item The first responder's most recent message ID.
\end{enumerate}

From here on, I will use the term node and first responders interchangeably.

\subsection{Initilization}
At the initialization phase of the Ad-hoc network, all nodes are required that they first report to the base before departing. 
At this step of the protocol, each of the nodes will be assigned their own private-key. 
Since at this step of the protocol we know exactly which nodes are going to be at the initial newtork, then every node will be able to have an initial table with everyone's public-key. 
This will be quintessential for nodes' capability of verifying messages.

\subsubsection{The Table for Authentication}
Recall that everyone will have a table with an entry for each ally node. The table will containing two important numbers for each node; the node's public-key and the node's latest message ID number. The latest message ID number is a counter-like number inserted to every message a node sends such that each node can idenfity ruplicate messages and be protected from malicious nodes trying to plot repaly attacks. Consider Table 1 for a depiction of this table:

\begin{table}[ht]
\caption{Athentication Table} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline
\hline %inserts double horizontal lines
First Responder Number & Public-Key & Latest Message ID  \\[0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
0 [base] & 69 & 669\\
1 & 50 & 837\\
% inserting body of the table
2 & 47 & 877 \\
3 & 45 & 300\\ [1ex]
% [1ex] adds vertical space
\hline
%inserts single line
\end{tabular}
\label{table:nonlin}
% is used to refer this table in the text
\end{table}

\subsubsection{Signing Mechanism}

The system should accept messages only from fellow first responders. 
Therefore it will be very important that nodes sign their messages with their private-key. 
Consider the following function that signs messages:

$$\textsc{SIGN}(message, my\_secret\_key, new\_message\_ID) = \sigma_{A}$$

The function returns a binary string $\sigma_{A}$, corresponding to the output of signing a message with the node's secret key. Since each private key assigned for each node is unique, each other node will need the corresponding public key to verify the signature. Note also that fi we want to be protected from replay attacks, a new message ID number has to be inserted to the message before signing it.

\subsection{Authentication Mechanism}
Even though it is important to sign messages for fellow nodes, its equally important that nodes are also able to verify the messages they receive. 
Therefore, consider the following verification function that takes a specific public-key and verifies if the chosen public-key matches the private-key used to sign the message:

$$\textsc{VERIFY}(signature, cooresponding\_public\_key) =  b $$

Notice that when we say, matches, we mean that verify is indeed the inverse function of sign when the correct public-key is applied relative to the correct private-key used to sign the message.
The output of $\textsc{VERIFY}$ will be either, the boolean true if the verification passes with that public-key, or false if it doesn't. If the verification fails, then the message will not be forwarded. 
\\
The way that a node decides which public-keys to apply is simple, since it knows it neighboring nodes, it indexes the Authentication table using each of the node's number and then obtains the corresponding public key.
This will work since, when forwarding messages, nodes re-sign the contents of the message.
Once the authentication has passed, then the node will use the following function to get the message:

$$\textsc{GET\_MESSAGE}(message, corresponding\_public\_key) = m$$
\\

This function returns the corresponding message when applying the inverse function of the sign function using the correct public-key.

\subsubsection{Dealing with replay attacks}

It is also a problem when malicious nodes get a valid signed message and then potentially try to flood the network with unnecessary messages. The way that our protocol deals with this problem is that, all messages are marked with a message ID number that is a counter that is matched to a specific node. This counter is increased everytime before a message is sent suring the signed procedure. Therefore the format of a message looks like this:

$$message = (message\_information, \ message\_ID\_Number)$$

After \textsc{VERIFY} validates that the current message indeed was sent at one point by an allied node, it will then check that the message ID number
is not outdated and thus invalid. The way to check this is by feeding the node number that made VERIFY accept along with the current ID message to the
following procedure:\\ \\
$def \ check\_ID\_number(node\_number, current\_message\_ID)$ \\
\hspace*{10 mm} $lastest\_ID\_number\_from\_table = this.authentication\_table[node\_number].get\_Latest\_Message\_ID();$
\hspace*{10 mm} $if \ (current\_message.ID > latest\_ID\_number\_from\_table):$\\
\hspace*{20 mm} $this.authentication\_table[node\_number].update\_Latest\_Message\_ID(current\_message\_ID)$\\
\hspace*{20 mm} $return \ true$ \\
\hspace*{10 mm} $else:$\\ \ 
\hspace*{20 mm} $return \ false$\\


\subsubsection{Scalability and updating the Authentication table}

After initialization, it is also possible that a new node will be added to the network. 
Therefore, it is important that other nodes are able to add new these new nodes to their Authentication table.

The way that this issue is addressed is by using the base as a trusted authority.
The new node is required to report to the base and from their obtain all of the public-keys of the node so far in the network and also obtain his own public and private-key. 

After this the base will send a special message (that he will sign) and distribute the new public-key to the network. 
Then the nodes will forward the message and re-sign it and then everyone will insert the new public-key of the new node to the network. Note that the base can also sign the new pair of keys for the new node and then the node can distribute them himself with sign message if neccessary.

\section{Analysis}

\subsection{Routing protocol}

As mentioned previously, our link-state scheme has both advantages and disadvantages compared to alternative protocols
such as distance vector. Overall, the analysis will show why a link-state-based protocol is preferable. The initial
setup cost of our protocol is greater than that of a distance vector based one, both consuming more network bandwidth
and requiring more time to converge. However, at each update interval, link-state only requires that new changes
be broadcast across the network, whereas distance vector will flood the network, simultaneously calculating the 
best path and updating every node's routing information. Given the relatively low speed of first responders, we 
conclude that the average network topology change over an advertisement interval is small. Therefore, link-state is
preferable because the average amount of information link-state will broadcast at each update interval in a real world
scenario is less than that of distance vector.
\\

\noindent Our design is also robust against topology changes between update intervals. Our protocol is designed to react
to major changes in topology by sending LSAs as soon as a change is detected. Because each node has a complete view of 
the network topology, each node can locally recompute the best route to the base as soon as it hears a link or node has 
been lost, updated, or added. A distance-vector protocol would be unable to recompute new routes to the base station
between update intervals because any updates to routing information need to be initiated from the base node.
\\

\noindent Finally, every link-state advertisement is broadcast to every node in the network. Resultantly, the base
will hear every link-state advertisement originating from a connected node. Our design takes advantage of this fact by
bundling GPS information on each node into its link-state advertisement. This optimization, available only to link-state
based protocols, simplifies our cost metric and fulfills a system requirement. 

\subsection{Authentication}
Under the assumption that the base and nodes are not going to be overrun, the authentication system presented is extremely secure. The reason that this is the case is because, at the initialization phase, everyone obtained a secure key from the trusted authority (the base). Therefore, if no new first responders join the network, every node in the network so far will be able to verify and sign every message that it receives or sends. This is great for networks where we have a fixed number of nodes in the network. \\

However, we can not ignore the potential scalability problem of this initial design. Therefore, the design presented in this paper also addresses the issue of adding new nodes to the network. If new nodes to the network are added, then they have to report to the base. After this step, they are able to get secure keys from the trusted authority. Since these key are bran new to the network, the rest of the nodes will not accept signatures from this node until the base distributes the new public key. Therefore, the base will forward the new public key to neighbour nodes and if neccesary, the new node can also forward this message signed by the base. Therefore, now the whole network can be updated with the new public key. \\

Since the private-keys are generated with RSA, the probability that a malicious node guesses a key and is able to find a colliding signature is negligible. This statement holds even when the node is able to see valid signatures because its extremely hard to obtain the private-key. This is true if one believes that factoring large numbers is an intractable problem with the present knowledge in computer science. Furthermore, even if a malicious node generates his own private-key, nodes are extremely unlikely to accept any messages that malicious node could sign. The only case where a malicious node could obtain a valid private-key, is if the key that he generated collides with a private-key that was already assigned. The probability of this even is extremely unlikely. The keys used for RSA are usually of length 2048 bits, therefore, the probability that one key generates by a malicious node a collides with an already generated private key is $2^{2048}$. The likelihood of collisions starts being a problem only when the graph start getting exponentially large. This case is extremely unlikely and even if this is the case, the number of bits for keys could just be increased, making RSA again more secure.\\

The authentication mechanism presented is also secure against replay attacks. If a malicious node tries to forward a valid message, first responders will reject the message (or messages), because they will extract the message ID and compare it with the latest message ID they have received. If the message ID is outdated, then first responders will not forward during replay attacks.


\section{Conclusion}

\section{References}

\end{document}
