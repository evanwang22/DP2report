\documentclass[letterpaper]{article}

\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{clrscode4e}


\begin{document}

\section{Introduction}

When deployed to a disaster-stricken area, first responders need to be able to efficiently communicate their
location and other information to their base camp. However, communication infrastructure is often unreliable
or inaccessible during these crises. To solve this problem, we design an ad-hoc wireless network of portable
devices that allows responders to send messages to their base camp in a reliable, efficient, and safe way.
Our rigorous design accounts for the rapid changes in network topology that occur as the responders move 
around, as well as the possible presence of malicious agents in the field. 

\subsection{Design Overview}

\subsection{Tradeoffs and Design Decisions}

\section{Design}

\subsection{Routing protocol}

An effective and efficient routing protocol is necessary for nodes to determine the best paths to send
packets to the base without constantly congesting the network.
\\

\noindent Our routing protocol is based on a link-state advertisement scheme in which neighboring nodes 
inform each other of incremental changes. Upon receiving an advertisement, a node will use the 
\textsc{broadcast} function to forward it to all its neighbors. As a result of this flooding process,
each node's routing table will contain a complete map of the network. Then, each node will independently
run a computation based on our cost metric to find the shortest routes to the base. As long as the nodes
have a consistent view of the topology and the same metric, resulting routes at different nodes will
correspond to a valid path.
\\

\noindent There are two data structures which our routing protocol uses: link-state advertisements (LSAs)
and routing tables. 
\\

\noindent Link-state advertisements have the following format:
\\

\noindent Routing tables:
\\

\noindent Initially, the network undergoes the following procedure that discovers the network topology:

\begin{enumerate}
  \item Each node constructs its link-state advertisement by calling \textsc{scan}. 
  \item Nodes begin to flood the network with their LSAs, and build up their routing tables based on
  the advertisements they receive.
  \item Once all the LSAs have been discarded according to the routing table protocol, each node will have
  a complete map of the network. This will take time proportional to the diameter of the network, because
  LSAs must be propogated throughout the entire network.
\end{enumerate}

\subsubsection{Handling changes to network topology}

Every 30 seconds (based on each node's internal clock), all nodes in the network will call \textsc{scan} in
order to determine whether or not the network topology and success probabilities of paths have changed.
If there are changes, nodes that are affected will construct LSAs accordingly and send these
advertisements into the network. Nodes that have not had major changes in status will not need to create
new advertisements. Resultingly, in a scenario in which not all nodes have changed their position
significantly over the course of 30 seconds, the network utilization of an update is smaller than the
network utilization of the initial network setup. Less network congestion implies that this update
procedure takes less time to complete than the setup.
\\

\noindent There exist, however, some cases in which the state of the network changes dramatically in 
between network update intervals, and it is desirable to send LSAs as soon as we recognize a change.
These situations are as follows:

\begin{enumerate}
  \item A path between two nodes fails, even though both are still connected to the network via other
  paths
  \item A node becomes disconnected from the network
  \item A node is re-connected or added to the network
  \item The loss probability of a path changes dramatically, significantly affecting the cost of
  routes which go through the path
\end{enumerate}

\noindent In order to determine if one of these situations has occurred, a node will issue a 
\textsc{scan} whenever it encounters one of a few anomalous scenarios:

\begin{enumerate}
  \item A node attempts to send a packet down a link, but experiences (TO BE DETERMINED NUMBER) 
  consecutive timeouts without a successful send.
  \item A node successfully sends packets down a link (TO BE DETERMINED NUMBER) times without
  experiencing a single timeout
  \item A node hears a scan from a node that is not in its view of the network topology

\noindent If one or more neighbor nodes from the last time the node scanned no longer appear in 
the \textsc{scan} results, either paths between nodes have been lost or at least one node has
been disconnected from the network. If the \textsc{scan} returns no results, then the node knows
that it has been disconnected from the network. 

\noindent When a node becomes disconnected from the network or the success probability of a link changes,
LSAs are sent by all nodes that are affected by the change. Nodes detect these changes by calling
the \textsc{scan} function and com

\subsection{Cost algorithm}

\subsection{Authentication}
When designing a communication system for first responders, its important that first responders are able to trust the messages they are receiving from fellow first responders. Therefore it is important to establish a mechanism by which first responders can authenticate “benign” messages (i.e. messages not sent a malicious adversary). In the protocol presented in this paper, the base will use the RSA public-key cryptosystem to generate private and public-keys that it will then distribute to the first responders. In addition, everyone will have a table with an entry for each fellow first responder containing two important numbers:

\begin{enumerate}
  \item The first responder's public-key. 
  \item The first responder's most recent message ID.
\end{enumerate}

From here on, I will use the term node and first responders interchangeably.

\subsubsection{The Table for Authentication}
Recall that everyone will have a table with an entry for each a fellow node. The table will containing two important numbers for each node; the node's public-key and the node's latest message ID number. The latest message ID number is a counter-like number inserted to every message a node sends such that each node can idenfity ruplicate messages and be protected from malicious reply attacks. Consider Table 1 for a depiction of this table:

\begin{table}[ht]
\caption{Athentication Table} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline
\hline %inserts double horizontal lines
First Responder Number & Public-Key & Latest Message ID  \\[0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
0 [base] & 69 & 669\\
1 & 50 & 837\\
% inserting body of the table
2 & 47 & 877 \\
3 & 45 & 300\\ [1ex]
% [1ex] adds vertical space
\hline
%inserts single line
\end{tabular}
\label{table:nonlin}
% is used to refer this table in the text
\end{table}

\subsubsection{Signing Mechanism}
At the initialization phase of the Ad-hoc network, all nodes are required that they first report to the base before departing. 
At this step of the protocol, each of the nodes will be assigned their own private-key. \\
Furthermore, because at this step of the protocol the total size of the network is known, every node will be able to have an initial table with every public-key assigned so far. 
This will be quintessential for nodes' capability of verifying messages.
\\
The system should accept messages only from first responders. Therefore it will be very important that nodes sign their messages with their private-key. Consider the following function that signs messages:

$$\textsc{SIGN}(message, my\_secret\_key) = \sigma_{A}$$

The function returns a binary string $\sigma_{A}$, corresponding to the output of signing the message with the node's secret key. Since each private key assigned for each node is unique, each other node will need the corresponding public key to verify the signature.

\subsection{Authentication Mechanism}
Even though it is important to sign messages for fellow nodes, its equally important that nodes are also able to verify the messages they receive. 
Therefore, consider the following verification function that takes a specific public-key and verifies if the chosen public-key matches the private-key used to sign the message:

$$\textsc{VERIFY}(signature, corooresponding\_public\_key) =  b $$

Notice that when we say, matches, we mean that verify is indeed the inverse function of sign when the correct public-key is applied relative to the correct private-key used to sign the message.
The output of $\textsc{VERIFY}$ will be either, the boolean true if the verification passes with that public-key, or false if it doesn't. If the verification fails, then the message will not be forwarded. 
\\
\\
The way that a node decides which public-keys to apply is simple, since it knows it neighboring nodes, it indexes the Authentication table using the node's number and then obtains the corresponding public key.
Once the authentication has passed, then the node will use the following function to get the message:

$$\textsc{GET\_MESSAGE}(message, corresponding\_public\_key) = m$$
\\

\subsubsection{Dealing with reply attacks }


-------------


\subsubsection{Scalability and updating the Authentication table}

In summary, nodes will always apply their private-keys to sign any message they need to send. To verify and get the message, nodes will use the corresponding public-key to get the message and pass the verification.

Jamming is a always a potential problem

\section{Analysis}

\section{Conclusion}

\section{References}

\end{document}
