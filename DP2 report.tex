\documentclass[letterpaper]{article}

\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{clrscode4e}


\begin{document}

\section{Introduction}

When deployed to a disaster-stricken area, first responders need to be able to efficiently communicate their
location and other information to their base camp. However, communication infrastructure is often unreliable
or inaccessible during these crises. To solve this problem, we design an ad-hoc wireless network of portable
devices that allows responders to send messages to their base camp in a reliable, efficient, and safe way.
Our rigorous design accounts for the rapid changes in network topology that  occur as the responders move 
around, as well as the possible presence of malicious agents in the field. 

\subsection{Design Overview}

\subsection{Tradeoffs and Design Decisions}

\section{Design}

\subsection{Routing tables}

Initially, and every thirty seconds onwards, the network undergoes the following update procedure that 
discovers changes in the network topology:

\begin{itemize}
  \item Each node issues one scan() message to populate its neighbor table.
  \item The base sends a route update broadcast() message to its neighbors, notifying them they are one hop
        away from the base. Each of these nodes updates their routing tables.
  \item Each of the neighbors from step 2 repeats that step themselves, aggregating the cost metric
        appropriately. Each node discards every broadcast() it receives after the first. 
        This procedure continues until all nodes have received a broadcast, and takes time proportional 
        to the diameter of the network.
\end{itemize}

\noindent The addition of new nodes to the network is also handled by this procedure. After this procedure, 
each node has multiple paths to the base and can begin using the metrics to estimate which paths are best.


\subsection{Cost algorithm}

\subsection{Authentication}
When designing a communication system for first responders, its important that first responders are able to trust the messages they are receiving from fellow first responders. Therefore it is important to establish a mechanism by which first responders can authenticate “benign” messages (i.e. messages not sent by a malicious adversary). In the protocol presented in this paper, the base will use the RSA public-key cryptosystem to generate private and public-keys that it will then distribute to the first responders. In addition, everyone will have a table with an entry for each fellow first responder containing two important numbers:

\begin{itemize}
\item[1] The first responder's public-key. 
\item[2] The first responder's most recent message ID.
\end{itemize}

From here on, I will use the term node and first responders interchangeably.

\subsection{Initilization}
At the initialization phase of the Ad-hoc network, all nodes are required that they first report to the base before departing. 
At this step of the protocol, each of the nodes will be assigned their own private-key. 
Since at this step of the protocol we know exactly which nodes are going to be at the initial newtork, then every node will be able to have an initial table with everyone's public-key. 
This will be quintessential for nodes' capability of verifying messages.

\subsubsection{The Table for Authentication}
Recall that everyone will have a table with an entry for each ally node. The table will containing two important numbers for each node; the node's public-key and the node's latest message ID number. The latest message ID number is a counter-like number inserted to every message a node sends such that each node can idenfity ruplicate messages and be protected from malicious nodes trying to plot repaly attacks. Consider Table 1 for a depiction of this table:

\begin{table}[ht]
\caption{Athentication Table} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline
\hline %inserts double horizontal lines
First Responder Number & Public-Key & Latest Message ID  \\[0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
0 [base] & 69 & 669\\
1 & 50 & 837\\
% inserting body of the table
2 & 47 & 877 \\
3 & 45 & 300\\ [1ex]
% [1ex] adds vertical space
\hline
%inserts single line
\end{tabular}
\label{table:nonlin}
% is used to refer this table in the text
\end{table}

\subsubsection{Signing Mechanism}

The system should accept messages only from fellow first responders. 
Therefore it will be very important that nodes sign their messages with their private-key. 
Consider the following function that signs messages:

$$\textsc{SIGN}(message, my\_secret\_key, new\_message\_ID) = \sigma_{A}$$

The function returns a binary string $\sigma_{A}$, corresponding to the output of signing a message with the node's secret key. Since each private key assigned for each node is unique, each other node will need the corresponding public key to verify the signature. Note also that fi we want to be protected from replay attacks, a new message ID number has to be inserted to the message before signing it.

\subsection{Authentication Mechanism}
Even though it is important to sign messages for fellow nodes, its equally important that nodes are also able to verify the messages they receive. 
Therefore, consider the following verification function that takes a specific public-key and verifies if the chosen public-key matches the private-key used to sign the message:

$$\textsc{VERIFY}(signature, cooresponding\_public\_key) =  b $$

Notice that when we say, matches, we mean that verify is indeed the inverse function of sign when the correct public-key is applied relative to the correct private-key used to sign the message.
The output of $\textsc{VERIFY}$ will be either, the boolean true if the verification passes with that public-key, or false if it doesn't. If the verification fails, then the message will not be forwarded. 
\\
\\
The way that a node decides which public-keys to apply is simple, since it knows it neighboring nodes, it indexes the Authentication table using each of the node's number and then obtains the corresponding public key.
This will work since, when forwarding messages, nodes re-sign the contents of the message.
Once the authentication has passed, then the node will use the following function to get the message:

$$\textsc{GET\_MESSAGE}(message, corresponding\_public\_key) = m$$
\\

This function returns the corresponding message when applying the inverse function of the sign function using the correct public-key.

\subsubsection{Dealing with repaly attacks }

It is also a problem when malicious nodes get a valid signed message and then potentially try to flood the network with unnecessary messages. The way that our protocol deals with this problem is that, all messages are marked with a message ID number that is a counter that is matched to a specific node. This counter is increased everytime before a message is sent suring the signed procedure. Therefore the format of a message looks like this:

$$message = (message\_information, \ message\_ID\_Number)$$

After \textsc{VERIFY} validates that the current message indeed was sent at one point by an allied node, it will then check that the message ID number is not outdated and thus invalid. The way to check this is by feeding the node number that made VERIFY accept along with the current ID message to the following procedure:\\ \\
$def \ check\_ID\_number(node\_number, current\_message\_ID)$ \\
\hspace*{10 mm} $lastest\_ID\_number\_from\_table = this.authentication\_table[node\_number].get\_Latest\_Message\_ID();$
\hspace*{10 mm} $if \ (current\_message.ID > latest\_ID\_number\_from\_table):$\\
\hspace*{20 mm} $this.authentication\_table[node\_number].update\_Latest\_Message\_ID(current\_message\_ID)$\\
\hspace*{20 mm} $return \ true$ \\
\hspace*{10 mm} $else:$\\ \ 
\hspace*{20 mm} $return \ false$\\


\subsubsection{Scalability and updating the Authentication table}

After initialization, it is also possible that a new node will be added to the network. 
Therefore, it is important that other nodes are able to add new these new nodes to their Authentication table.

The way that this issue is addressed is by using the base as a trusted authority.
The new node is required to report to the base and from their obtain all of the public-keys of the node so far in the network and also obtain his own public and private-key. 

After this the base will send a special message (that he will sign) and distribute the new public-key to the network. 
Then the nodes will forward the message and re-sign it and then everyone will insert the new public-key of the new node to the network. Note that the base can also sign the new pair of keys for the new node and then the node can distribute them himself with sign message if neccessary.

\section{Analysis}

\subsection{Authentication}
Under the assumption that the base and nodes are not going to be overrun, the authentication system presented is extremely secure. The reason that this is the case is because, at the initialization phase, everyone obtained a secure key from the trusted authority (the base). Therefore, if no new first responders join the network, every node in the network so far will be able to verify and sign every message that it receives or sends. This is great for networks where we have a fixed number of nodes in the network. \\

However, we can not ignore the potential scalability problem of this initial design. Therefore, the design presented in this paper also addresses the issue of adding new nodes to the network. If new nodes to the network are added, then they have to report to the base. After this step, they are able to get secure keys from the trusted authority. Since these key are bran new to the network, the rest of the nodes will not accept signatures from this node until the base distributes the new public key. Therefore, the base will forward the new public key to neighbour nodes and if neccesary, the new node can also forward this message signed by the base. Therefore, now the whole network can be updated with the new public key. \\

Since the private-keys are generated with RSA, the probability that a malicious node guesses a key and is able to find a colliding signature is negligible. This statement holds even when the node is able to see valid signatures because its extremely hard to obtain the private-key. This is true if one believes that factoring large numbers is an intractable problem with the present knowledge in computer science. Furthermore, even if a malicious node generates his own private-key, nodes are extremely unlikely to accept any messages that malicious node could sign. The only case where a malicious node could obtain a valid private-key, is if the key that he generated collides with a private-key that was already assigned. The probability of this even is extremely unlikely. The keys used for RSA are usually of length 2048 bits, therefore, the probability that one key generates by a malicious node a collides with an already generated private key is $2^{2048}$. The likelihood of collisions starts being a problem only when the graph start getting exponentially large. This case is extremely unlikely and even if this is the case, the number of bits for keys could just be increased, making RSA again more secure.\\

The authentication mechanism presented is also secure against replay attacks. If a malicious node tries to forward a valid message, first responders will reject the message (or messages), because they will extract the message ID and compare it with the latest message ID they have received. If the message ID is outdated, then first responders will not forward during replay attacks.

\section{Conclusion}

\section{References}

\end{document}
